# Задание

Задание проверяет понимание технологий и умение это понимание применять на практике на базе вашего существующего опыта.


Репозиторий содержит некоторе решение некоторой задачи. И задача и решене здесь приведены
только для наглядности. Ответ на каждый вопрос принимается исключительно про ваш реальный опыт над реальным проектом.
Мы ожидаем развернутых ответов.

Решением задания будет написание ответов на вопросы ниже. Ответ можно отправить в свободной форме.

## Аутентификация

Для аутентификации в этом репозитории используется jwt токен. Технология известная, зарекомендовавшая себя. 
Давайте в ней усомнимся. Как минимум - в целесообразности гонять в каждом http запросе такой большой кусок данных.
Расскажите о проектах с вашим участием, где использовалась другая техника авторизации. 
Если в таких проектах вы бы могли выбирать - выбрали бы вы аутентификацию через jwt? Если да, то почему?
В каком проекте, в котором вы участвовали, вы бы наоборот, вместо jwt выбрали что-то другое и почему?

**Ответ.** В одном проекте делали сессии в Redis и в cookie только id сессии. В запросе летит мало данных, логаут - удалил сессию и всё. JWT бы там взял, если бы не было общего хранилища - например несколько бэкендов или мобилка. А вот здесь, в этом репо, где каждый запрос тащит JWT в заголовке, я бы сделал короткий токен в cookie и сессию — меньше трафика и проще отозвать доступ.

---

## Идентификация

В этом репозтории в некоторых таблицах для идентификации записи используется uuid. Эта техника удобна по нескольким параметрам.
Сложно представить, чтобы использование uuid во всех таблицах - как стандарта - создало бы где нибудь проблему.
Но может быть в вашей практике встречались случаи, где uuid как идентификатор стал проблемой или мог бы стать проблемой?
Опишите где и почему.

**Ответ.** Два момента. Первый - на больших таблицах UUID как первичный ключ давал просадку по скорости: индексы фрагментировались, джойны тормозили. В таком случае для «горячих» таблиц лучше bigint или snowflake, UUID оставить для API. Второй - в логах и в поддержке длинный UUID неудобен, приходилось вводить короткий id для людей. В остальном UUID проблем не создавал.

---

## Организация кода

В этом репозитории, серверный код сделан на базе NestJS. 
DI, services, controllers, middleware, decorators - в этом, как и во многих других подходах есть плюсы и выгоды.
Расскажите с примерами из опыта о реальной пользе того или иного механизма организации кода лично для вас или
для вашей команды, а может быть - для компании. Если есть какой-то механим, который также - для вас, команды 
или компании наоборот - создавал сложности - тоже расскажите.

**Ответ.** DI удобен: зависимости в конструкторе видны сразу, в тестах подменяешь моками без костылей. Разделение на контроллеры и сервисы - логика в одном месте, не размазана. Декораторы вроде guards — один раз написал «только админ» и вешаешь на эндпоинты. Минусы: циклические зависимости между модулями вылазили, приходилось выносить общее в отдельный модуль или forwardRef. И новичкам без опыта в Nest сложновато - много магии в декораторах.

---

## Реактивность

В этом репозитории, для интерфейса используется React. Его название связано с реактивным подходом к отрисовке
интерфейса - мы меняем состояние, а интерфейс перерисовывается в соответствии с этим. 
Сам посыл подкупает - разработчик заботится о состоянии, остальное за него делает фреймворк. 
Такой подход, конечно, помимо React реализуют и многие другие фреймворки. 
Были ли ситуации в вашем опыте, когда реактивность была не плюсом, а помехой? Если да, расскажите на примере.
Если был опыт построения рендера интерфеса на другом принципе, раскажите на каком и какие были резльтаты?
Расскажите на конкретных примерах, что вам доставляет неудобства в том, как реактивность реализована
непосредственно во фреймворке React?

**Ответ.** Реактивность мешала на тяжёлой таблице с фильтрами: поменял одно - пересчиталось всё, ре-рендер по всему поддереву. Спасались useMemo и разбиением на компоненты. Серверный рендер (Jinja, Thymeleaf) пробовал - проще по модели, но для интерактива быстро превращается в кашу. В React бесит возня с зависимостями в useEffect и useMemo: забыл что-то в массив - баг, лишнее добавил — лишние срабатывания. И отлаживать порядок «запрос -> ответ -> setState -> ре-рендер» бывает больно.
